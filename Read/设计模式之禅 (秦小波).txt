- Your Highlight on Location 287-288 | Added on Monday, September 29, 2014 11:46:55 PM

世界上最难的事有两件：一是让人心甘情愿地把钱掏出来给你，二是把自己的思想灌输到别人的脑子里。
==========
- Your Highlight on Location 341-342 | Added on Tuesday, September 30, 2014 5:43:53 AM

给自己制定一个计划，每天编写一段代码，不需要太多，200行足够，时不时地把设计模式融入到你的代码中。
==========
- Your Highlight on Location 401-406 | Added on Tuesday, September 30, 2014 5:49:02 AM

只要做过项目，肯定要接触到用户、机构、角色管理这些模块，基本上使用的都是RBAC模型（Role-Based Access Control，基于角色的访问控制，通过分配和取消角色来完成用户权限的授予和取消，使动作主体（用户）与资源的行为（权限）分离），确实是一个很好的解决办法。我们这里要讲的是用户管理、修改用户的信息、增加机构（一个人属于多个机构）、增加角色等，用户有这么多的信息和行为要维护，我们就把这些写到一个接口中，都是用户管理类嘛，我们先来看它的类图，如图1-1所示。
==========
- Your Highlight on Location 401-409 | Added on Tuesday, September 30, 2014 5:49:38 AM

只要做过项目，肯定要接触到用户、机构、角色管理这些模块，基本上使用的都是RBAC模型（Role-Based Access Control，基于角色的访问控制，通过分配和取消角色来完成用户权限的授予和取消，使动作主体（用户）与资源的行为（权限）分离），确实是一个很好的解决办法。我们这里要讲的是用户管理、修改用户的信息、增加机构（一个人属于多个机构）、增加角色等，用户有这么多的信息和行为要维护，我们就把这些写到一个接口中，都是用户管理类嘛，我们先来看它的类图，如图1-1所示。 太Easy的类图了，我相信，即使是一个初级的程序员也可以看出这个接口设计得有问题，用户的属性和用户的行为没有分开，这是一个严重的错误！这个接口确实设计得一团糟，应该把用户的信息抽取成一个BO（Bussiness Object，业务对象），把行为抽取成一个Biz（Business Logic，业务逻辑），按照这个思路对类图进行修正，如图1-2所示。
==========
- Your Highlight on Location 425-426 | Added on Tuesday, September 30, 2014 5:57:15 AM

单一职责原则的定义是：应该有且仅有一个原因引起类的变更。
==========
- Your Highlight on Location 615-618 | Added on Tuesday, September 30, 2014 6:48:56 AM

在具体应用场景中就要考虑下面这个问题了：子类是否能够完整地实现父类的业务，否则就会出现像上面的拿枪杀敌人时却发现是把玩具枪的笑话。 注意　如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。
==========
- Your Highlight on Location 714-717 | Added on Tuesday, September 30, 2014 7:17:47 AM

子类在没有覆写父类的方法的前提下，子类方法被执行了，这会引起业务逻辑混乱，因为在实际应用中父类一般都是抽象类，子类是实现类，你传递一个这样的实现类就会“歪曲”了父类的意图，引起一堆意想不到的业务逻辑混乱，所以子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松。
==========
- Your Highlight on Location 797-800 | Added on Tuesday, September 30, 2014 7:50:30 AM

这在20世纪90年代“个人英雄主义”编程模式中还是比较适用的，一个人完成所有的代码工作。但在现在的大中型项目中已经是完全不能胜任了，一个项目是一个团队协作的结果，一个“英雄”再牛也不可能了解所有的业务和所有的技术，要协作就要并行开发，要并行开发就要解决模块之间的项目依赖关系，那然后呢？依赖倒置原则就隆重出场了！
==========
- Your Highlight on Location 844-845 | Added on Tuesday, September 30, 2014 8:34:49 AM

我们引入一个JMock工具，其最基本的功能是根据抽象虚拟一个对象进行测试，
==========
- Your Highlight on Location 852-855 | Added on Tuesday, September 30, 2014 8:42:03 AM

我们只需要一个ICar的接口，就可以对Driver类进行单元测试。从这一点来看，两个相互依赖的对象可以分别进行开发，孤立地进行单元测试，进而保证并行开发的效率和质量，TDD开发的精髓不就在这里吗？测试驱动开发，先写好单元测试类，然后再写实现类，这对提高代码的质量有非常大的帮助，特别适合研发类项目或在项目成员整体水平比较低的情况下采用。
==========
